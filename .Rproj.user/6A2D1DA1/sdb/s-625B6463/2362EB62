{
    "contents" : "adapt.step <- function(formula, data, adaptive.object, selection.method, adapt) {\n    result = list()\n    \n    #Pull out the relevant data\n    response.name = rownames(attr(terms(formula, data=data), 'factors'))[1]\n    response.col = which(colnames(data)==response.name)\n    predictor.names = attr(terms(formula, data=data), 'term.labels')\n    \n    y = as.matrix(data[,response.col])\n    x = as.matrix(data[,predictor.names])\n\n    colnames(x) = predictor.names\n    colnames(y) = response.name\n    \n    m <- ncol(x)\n    n <- nrow(x)\n    p.max = min(m-2, floor(n/2))\n    \n    if (adapt==TRUE) {\n        result[['meanx']] = adaptive.object[['meanx']]\n        result[['scale']] = adaptive.object[['adaweight']]\n    } else {\n        result[['meanx']] = sapply(predictor.names, function(x) return(0))\n        result[['scale']] = sapply(predictor.names, function(x) return(1))\n    }\n\n    x.centered = sweep(x, 2, result[['meanx']], '-')\n    x.scaled = sweep(x.centered, 2, result[['scale']], '*')\n    \n    result[['model']] = model = lars(x=x.scaled, y=y, type='lar', max.steps=p.max, normalize=FALSE)\n  \n    if (!is.na(pmatch('cv', selection.method))) {\n        result[['cv']] = cv = cv.lars(y=y, x=x.scaled, type='lar', index=1:p.max, K=n, plot.it=FALSE, mode='step', normalize=FALSE)\n        if (selection.method == 'cv.overshrink') {\n            err.min = min(cv$cv)\n            err.tol = err.min + cv$cv.error[which.min(cv$cv)]\n            which.tol = which(cv$cv<err.tol)\n            result[['lambda.index']] = lambda.index = max(min(which.tol, na.rm=TRUE), 2, na.rm=TRUE)\n        } else if (selection.method == 'cv') {\n            result[['lambda.index']] = lambda.index = max(which.min(cv$cv), 2, na.rm=TRUE)\n        }\n        result[['MSEP']] = cv$cv[lambda.index]\n        result[['RMSEP']] = sqrt(result[['MSEP']])\n    } else if (selection.method == 'AICc') {\n        resid = as.matrix(sweep(predict(model, newx=x.scaled, type='fit')$fit, 1, y, '-'))\n        ssr = apply(resid, 2, function(x) sum(x**2))\n        s2 = ssr[ncol(resid)] / nrow(resid)\n        df = apply(predict(model, type='coefficients')$coefficients, 1, function(x) sum(x != 0))\n        AICc = ssr/s2 + 2*df + 2*df*(df+1)/(nrow(resid)-df-1)\n        result[['lambda.index']] = lambda.index = which.min(AICc)\n    }  \n    result[['predictors']] = predictor.names\n    result[['fitted']] = predict.lars(model, newx=x.scaled, type='fit', s=lambda.index, mode='step')$fit\n    result[['residuals']] = y-result[['fitted']]\n    result[['vars']] = names(which(model$beta[lambda.index,] != 0))\n    \n    coefs = predict.lars(model, type='coefficients', s=lambda.index, mode='step')\n    result[['coef']] = coefs$coefficients[which(coefs$coefficients!=0)]\n    result[['Intercept']] = predict(model, newx=matrix(0,1,m), type='fit', s=lambda.index, mode='step')$fit\n    \n    return(result)\n}\n",
    "created" : 1406740799524.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1754351767",
    "id" : "2362EB62",
    "lastKnownWriteTime" : 1406737761,
    "path" : "C:/Users/wrbrooks/git/adapt/R/adapt.step.R",
    "project_path" : "R/adapt.step.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}